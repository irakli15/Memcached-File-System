## memcached-ში შენახვა
ერთადერთი აღსანიშნავი ამ ნაწილში არის ის რომ მონაცემების დამატება/წაშლისას შედეგს ვუსმენ (ანუ noreply-ს არ ვეუბნები). მოსმენის გარეშე საგრძნობლად იზრდება ჩაწერის სიჩქარე, თუმცა ერორ ჩექინგი აღარ გვექნება, ამიტომაც გადავწყვიტე დავტოვო პასუხის ნახვა.

# inode სტრუქტურა


## inumber
რადგანაც სექტორები არ გვაქვს ფიქსირებულად გადანომრილი და გადანომვრას მე ვქმნი, გადავწყვიტე რომ inumber-ის პირველი 4 ბაიტი ყოფილიყო ფაილის აინოდის ნომერი, დანარჩენი 4 კი ფაილში შემავალი ბლოკების ნომრები. 0 ინდექსის ბლოკი აინოდია.
ასეთი სისტემით შემიძლია მაქსიმუმ 2^32 ფაილი შევინახო, თითოეული მაქსიმუმ 2^32*4 კბ ზომის, რაც სავსებით საკმარისია.

ასეთი სტრუქტურით არ მომიწევს დაკავებული და თავისუფალი სექტორის ნომრების რეინჯების მენეჯმენტი, მხოლოდ მომიწევს 4 ბაიტიანი ზომის უნიკალური რიცხვების გამოყოფა და მენეჯმენტი. ამ შემთხვევაში ფაილების შიდა ფრაგმენტაციაზე ზრუნვა საერთოდ არ მომიწევს (იმ მხრივ რომ სექტორების გადანომვრა უწყვეტი იქნება და რეინჯები ძებნა არ მჭირდება, თორემ სექტორები ცალ-ცალკე იქნება მემქეშდში შენახული),ხოლო თავად ფაილის inumber-ების ფრაგმენტაციაზე ზრუნვა მარტივი იქნება.

## disk inode
```c
struct disk_inode{
  inumber_t inumber; //8
  size_t length; //8
  int mode; //4 
  size_t nlink; // 8
  xattr_t xattrs[XATTR_COUNT];
  char unused[INODE_PAD_SIZE];
};
```

თავად აინოდის ზომა 4 კილობაიტია, წევრის ზომები მითითებულია კომენტარის სახით.
xattrs წევრი წარმოადგენს extended attribute-ს სანახ სტრუქტურას, მისი თითოეული წევრის ზომა 172 ბაიტია, შესაბამისად ზომები ითვლება ასე:

```c
#define BLOCK_SIZE 4096
#define LEFT_OVER (BLOCK_SIZE - 36)

#define XATTR_COUNT (LEFT_OVER/172)
#define INODE_PAD_SIZE (LEFT_OVER - (XATTR_COUNT*172))
```
აინოდის ზომა ზუსტად უნდა იყოს 4კბ, ამიტომ ივსება გამოუყენებელი ბაიტებით დარჩენილი ადგილი.

mode ცვლადი გამოიყენება აინოდის ტიპის დასადგენად (ფაილია თუ ფოლდერ), ასევე უფლებების გასაგებად.
nlink ჰარდ ლინკების მთვლელია, აინოდი მხოლოდ მაშინ წაიშლება როცა ეგ მაჩვენებელი 1 გახდება. დირექტორიას ჰარდ ლინკების მხარდაჭერა არ აქვს, ამიტომ სულ 1-ია ეგ მნიშვნელობა.

extended attributes ასეთი სახე აქვს:
```c
struct xattr {
  char key[43];
  char value[128];
  char size; //is it in use?
};
```
ატრიბუტის მნიშვნელობის და გასაღების მნიშვნელობებიც შესაბამისადაა.

## inode-ის ბლოკებში ჩაწერა-წაკითხვა
ჩაწერა-წაკითხვა მიმდინარეობს პინტოს-ის მსგავსად. ერთადერთი აღსანიშნავი ისაა, რომ თავად აინოდის ჩაწერა-წაკითხვა inode_write და inode_read-ის მეშვეობით არ ხდება, არამედ პირდაპირ memcached_client-დან block-ის ფუნქციებით ხდება.

აინოდიდან რანდომ წაკითხვა სწრაფი იქნება, რადგან ოფსეტის მიხედვით დაითვლება რომელ ბლოკში წერია ინფორმაცია და მხოლოდ შესაბამის 4კბ ბლოკებს მოითხოვს.

# free map
ეს ახდენს აინოდის რიცხვების ალოკაციას. ამჟამად უბრალოდ ერთი რიცხვი აქვს და ინკრემენტულად იძლევა რიცხვს ყოველი alloc_inumber()-ის გამოძახებაზე. სულ 2^32-2 (0 რეზერვირებულია free map-ის აინოდისთვის, 1 root dir-ისთვის) რიცხვის მოცემა შეუძლია რაც ჩვენთვის საკმარისია. 
free map-ს აქვს თავისი აინოდი, სადაც სისტემის გათიშვისას შეინახება ამჟამად რა რიცხვზეა ასული, რომ ახლიდან ჩართვისას თავიდან არ დაიწყოს ათვლა და ვერ შეძლოს აინოდების შექმნა. 

# directory
```c
#define NAME_MAX_LEN 203

struct dir{
    inode_t* inode;
    size_t pos;
};

struct dir_entry{
    inumber_t inumber;
    char name[NAME_MAX_LEN + 1];
    int in_use;
};
```
აინოდში ინახება  dir_entry ობიექტები, თუ ჩანაწერი დაემატება დირექტორიას და შემდეგ წაიშლება, in_use = 0 გახდება და შეგვეძლება ახლიდან ჩაწერა.
სახელის სიგრძე ფიქსირებულია 203 სიმბოლო (ზუსტად ეს რიცხვი იმიტომ რომ alignment-ში ტყუილად არ დამეკარგა ბაიტები).
დირექტორიებს მუშაობა შეუძლიათ როგორც რელაციურ, ისე აბსოლუტურ მისამართებთან.

თუ დირექტორიაში იმდენი ჩანაწერი შევიდა, რომ რამდენიმე ბლოკი დასჭირდა დასატევად, ამ ჩანაწერების წაშლის შემდეგ დირექტორიის გათავისუფლებული ბლოკები არ იშლება.

# filesys
ეს თავს უყრის როგორც დირექტორიების მენეჯმენტს ასევე ფაილების მენეჯმენტს.
filesys_init() აკეთებს საჭირო სისტემების ინიციალიზაციას, free map-ის აინოდის და root dir-ის გახსნის ჩათვლით, თუ რომელიმე ვერ იპოვა, მაშინ მემქეშდი გასუფთავდება და ახლიდან ჩაიწერება ეს ორი აინოდი.

# main
აქ ხდება ფიუზის api-ს გამოყენება.

ეს სტრუქტურა ძირითადად getattr-ისთვისაა, რადგან ატრიბუტების გაგება შეიძლება როგორც ფაილისთვის ისე დირექტორიისთვის დაგვჭირდეს, ამ უკანასკნელებს კი განსხვავებული სტრუქტურები აქვთ და განსხვავებულად უნდა ამოვიღო აინოდიდან მონაცემები.
```c
struct file_handle {
	void* ptr;
	int type;
};
```
ამ სტრუქტურის კიდევ ერთი დანიშნულება ისაა, რომ გახსნილ ფაილს ვაძლევ ფიუზის file handler (fi->fh), რომ სხვა ფუნქციაში პირდაპირ ეს ობიექტი მომცეს და არ დამჭირდეს ყოველთვის path-ის მიხედვით ახლიდან მოძიება და გახსნა.

fsyncdir, flush, fsync ფუნქციები უბრალოდ 0-ს აბრუნებს. ჩემი ფაილური სისტემა ყოველთვის წერს მემქეშდში ინფორმაციას, ამიტომ ამ ფუნქციებს ჩემთან დაიმპლემენტირება არ სჭირდება.