<!-- ### **memcached-ში შენახვა** -->

# inode სტრუქტურა


## inumber
რადგანაც სექტორები არ გვაქვს ფიქსირებულად გადანომრილი და გადანომვრას მე ვქმნი, გადავწყვიტე რომ inumber-ის პირველი 4 ბაიტი ყოფილიყო ფაილის აინოდის ნომერი, დანარჩენი 4 კი ფაილში შემავალი ბლოკების ნომრები. 0 ინდექსის ბლოკი აინოდია.
ასეთი სისტემით შემიძლია მაქსიმუმ 2^32 ფაილი შევინახო, თითოეული მაქსიმუმ 2^32*4 კბ ზომის, რაც სავსებით საკმარისია.

ასეთი სტრუქტურით არ მომიწევს დაკავებული და თავისუფალი სექტორის ნომრების რეინჯების მენეჯმენტი, მხოლოდ მომიწევს 4 ბაიტიანი ზომის უნიკალური რიცხვების გამოყოფა და მენეჯმენტი. ამ შემთხვევაში ფაილების შიდა ფრაგმენტაციაზე ზრუნვა საერთოდ არ მომიწევს (იმ მხრივ რომ სექტორების გადანომვრა უწყვეტი იქნება და რეინჯები ძებნა არ მჭირდება, თორემ სექტორები ცალ-ცალკე იქნება მემქეშდში შენახული),ხოლო თავად ფაილის inumber-ების ფრაგმენტაციაზე ზრუნვა მარტივი იქნება.

## disk inode
```c
struct disk_inode{
  inumber_t inumber; //8
  size_t length; //8
  int mode; //4 
  size_t nlink; // 8
  xattr_t xattrs[XATTR_COUNT];
  char unused[INODE_PAD_SIZE];
};
```

თავად აინოდის ზომა 4 კილობაიტია, წევრის ზომები მითითებულია კომენტარის სახით.
xattrs წევრი წარმოადგენს extended attribute-ს სანახ სტრუქტურას, მისი თითოეული წევრის ზომა 172 ბაიტია, შესაბამისად ზომები ითვლება ასე:

```c
#define BLOCK_SIZE 4096
#define LEFT_OVER (BLOCK_SIZE - 36)

#define XATTR_COUNT (LEFT_OVER/172)
#define INODE_PAD_SIZE (LEFT_OVER - (XATTR_COUNT*172))
```
აინოდის ზომა ზუსტად უნდა იყოს 4კბ, ამიტომ ივსება გამოუყენებელი ბაიტებით დარჩენილი ადგილი.

mode ცვლადი გამოიყენება აინოდის ტიპის დასადგენად (ფაილია თუ ფოლდერ), ასევე უფლებების გასაგებად.
nlink ჰარდ ლინკების მთვლელია, აინოდი მხოლოდ მაშინ წაიშლება როცა ეგ მაჩვენებელი 1 გახდება. დირექტორიას ჰარდ ლინკების მხარდაჭერა არ აქვს, ამიტომ სულ 1-ია ეგ მნიშვნელობა.