## **memcached-ში შენახვა**

# inode სტრუქტურა
რადგანაც ქსელში გასაგზავნი მონაცემების სიდიდე 1500 ბაიტზე მეტი არ უნდა იყოს (წინააღმდეგ შემთხვევაში პაკეტის დაჭრა იქნება საჭირო), ბლოკის ზომას ვიღებ 1024 ბაიტს, რადგანაც თავად ბლოკთან ერთად სხვა ინფორმაციაც უნდა გაიგზავნოს ქსელში (მაგ.: key, attributes, etc.), დარჩენილი ზომა წესით საკმარისი იქნება დანარჩენი მონაცემებისთვის.


* inumber      - 8 bytes
* length       - 4 bytes
* direct_ptrs  - 4*x bytes
* ind_ptrs     - 4 bytes
* dbl_ind_ptrs - 4*16 bytes
* **to be continued**

პირობის თანახმად, ფაილურ სისტემას უნდა ჰქონდეს 1GB ზომის ფაილების მხარდაჭერა.
ამის გაკეთება შეიძლებოდა ორნაირად, ან გამეკეთებინა სამმაგი არაპირდაპირი მიმთითებელი, ან რამდენიმე ორმაგი არაპირდაპირი მიმთითებელი. გართულების თავიდან ასაცილებლად ორმაგი ავირჩიე.
თითოეულ ბლოკი 1024 ბაიტიანია, თითოეული მიმთითებელი კი 4 ბაიტიანი, შესაბამისად თითო ბლოკი დაიტევს 2^10/2^2 = 2^8 მიმთითებელს.
ერთი არაპირდაპირი მიმთითებელი => 2^8 KB.
16 ორმაგი არაპირდაპირი მიმთითებელი => 2^8*2^8*2^4 = 2^20 KB = 1GB.
საბოლოო ჯამში, ფაილის მაქსიმალური ზომა იქნება: 1GB + 2^8KB + **4*x B**.

## inumber
რადგანაც სექტორები არ გვაქვს ფიქსირებულად გადანომრილი და გადანომვრას მე ვქმნი, გადავწყვიტე რომ inumber-ის პირველი 4 ბაიტი ყოფილიყო ფაილის სექტორის ნომერი, დანარჩენი 4 კი ფაილში შემავალი სექტორების ნომრები, რომელთა გადანომვრა იწყება 0-დან ყოველი ფაილისთვის.

ასეთი სტრუქტურით არ მომიწევს დაკავებული და თავისუფალი სექტორის ნომრების რეინჯების მენეჯმენტი, მხოლოდ მომიწევს 4 ბაიტიანი ზომის უნიკალური რიცხვების გამოყოფა და მენეჯმენტი. ამ შემთხვევაში ფაილების შიდა ფრაგმენტაციაზე ზრუნვა საერთოდ არ მომიწევს (იმ მხრივ რომ სექტორების გადანომვრა უწყვეტი იქნება და რეინჯები ძებნა არ მჭირდება, თორემ სექტორები ცალ-ცალკე იქნება მემქეშდში შენახული), ხოლო თავად ფაილის inumber-ების ფრაგმენტაციაზე ზრუნვა მარტივი იქნება.